<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selector Telemetry Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            color: #333;
        }
        
        .dashboard {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
            transition: transform 0.2s;
        }
        
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .metric-card h3 {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .metric-change {
            font-size: 0.9em;
            color: #666;
        }
        
        .metric-change.positive {
            color: #28a745;
        }
        
        .metric-change.negative {
            color: #dc3545;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .chart-card h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3em;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
        }
        
        .alerts-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        
        .alerts-section h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3em;
        }
        
        .alert-item {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid;
        }
        
        .alert-item.critical {
            background-color: #f8d7da;
            border-color: #dc3545;
        }
        
        .alert-item.warning {
            background-color: #fff3cd;
            border-color: #ffc107;
        }
        
        .alert-item.info {
            background-color: #d1ecf1;
            border-color: #17a2b8;
        }
        
        .alert-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .alert-time {
            font-size: 0.9em;
            color: #666;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-indicator.healthy {
            background-color: #28a745;
        }
        
        .status-indicator.warning {
            background-color: #ffc107;
        }
        
        .status-indicator.error {
            background-color: #dc3545;
        }
        
        .refresh-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
        }
        
        .refresh-button:hover {
            background: #5a67d8;
        }
        
        .time-selector {
            margin-left: 20px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>Selector Telemetry Dashboard</h1>
            <p>Real-time monitoring and analytics for selector operations</p>
            <div style="margin-top: 20px;">
                <button class="refresh-button" onclick="refreshDashboard()">Refresh</button>
                <select class="time-selector" id="timeRange" onchange="refreshDashboard()">
                    <option value="1h">Last Hour</option>
                    <option value="6h">Last 6 Hours</option>
                    <option value="24h" selected>Last 24 Hours</option>
                    <option value="7d">Last 7 Days</option>
                    <option value="30d">Last 30 Days</option>
                </select>
            </div>
        </div>

        <div id="loadingIndicator" class="loading" style="display: none;">
            <h3>Loading telemetry data...</h3>
        </div>

        <div id="errorContainer"></div>

        <div class="metrics-grid" id="metricsGrid">
            <!-- Metrics will be populated here -->
        </div>

        <div class="charts-grid">
            <div class="chart-card">
                <h3>Performance Trends</h3>
                <div class="chart-container">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h3>Selector Usage Distribution</h3>
                <div class="chart-container">
                    <canvas id="usageChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h3>Confidence Score Distribution</h3>
                <div class="chart-container">
                    <canvas id="confidenceChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h3>Error Rate Trends</h3>
                <div class="chart-container">
                    <canvas id="errorChart"></canvas>
                </div>
            </div>
        </div>

        <div class="alerts-section">
            <h3>Recent Alerts</h3>
            <div id="alertsContainer">
                <!-- Alerts will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Global state
        let charts = {};
        let currentData = null;
        
        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            refreshDashboard();
        });
        
        // Main refresh function
        async function refreshDashboard() {
            showLoading(true);
            hideError();
            
            try {
                const timeRange = document.getElementById('timeRange').value;
                const data = await fetchTelemetryData(timeRange);
                currentData = data;
                
                updateMetrics(data.metrics);
                updateCharts(data);
                updateAlerts(data.alerts);
                
            } catch (error) {
                showError('Failed to load telemetry data: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // Fetch telemetry data from API
        async function fetchTelemetryData(timeRange) {
            // Mock API call - replace with actual API endpoint
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(generateMockData(timeRange));
                }, 1000);
            });
        }
        
        // Generate mock data for demonstration
        function generateMockData(timeRange) {
            const now = new Date();
            let startTime;
            
            switch(timeRange) {
                case '1h':
                    startTime = new Date(now.getTime() - 60 * 60 * 1000);
                    break;
                case '6h':
                    startTime = new Date(now.getTime() - 6 * 60 * 60 * 1000);
                    break;
                case '24h':
                    startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                    break;
                case '7d':
                    startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case '30d':
                    startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                default:
                    startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            }
            
            // Generate metrics
            const metrics = {
                totalOperations: Math.floor(Math.random() * 50000) + 10000,
                averageResolutionTime: Math.random() * 100 + 50,
                successRate: Math.random() * 0.1 + 0.9,
                errorRate: Math.random() * 0.05,
                averageConfidence: Math.random() * 0.2 + 0.75,
                memoryUsage: Math.random() * 200 + 50,
                throughput: Math.random() * 1000 + 500,
                activeSelectors: Math.floor(Math.random() * 100) + 50
            };
            
            // Generate time series data
            const timePoints = generateTimeSeries(startTime, now, timeRange);
            const performanceData = timePoints.map((time, index) => ({
                time: time,
                resolutionTime: Math.random() * 100 + 50 + Math.sin(index / 10) * 20,
                throughput: Math.random() * 1000 + 500 + Math.cos(index / 10) * 200
            }));
            
            const errorData = timePoints.map((time, index) => ({
                time: time,
                errorRate: Math.random() * 0.05 + Math.sin(index / 20) * 0.02
            }));
            
            // Generate usage distribution
            const usageData = [
                { selector: 'product_title', count: Math.floor(Math.random() * 1000) + 500 },
                { selector: 'price_element', count: Math.floor(Math.random() * 800) + 400 },
                { selector: 'add_to_cart', count: Math.floor(Math.random() * 600) + 300 },
                { selector: 'description', count: Math.floor(Math.random() * 400) + 200 },
                { selector: 'image_gallery', count: Math.floor(Math.random() * 300) + 100 }
            ];
            
            // Generate confidence distribution
            const confidenceData = [
                { range: '0.9-1.0', count: Math.floor(Math.random() * 1000) + 2000 },
                { range: '0.8-0.9', count: Math.floor(Math.random() * 800) + 1000 },
                { range: '0.7-0.8', count: Math.floor(Math.random() * 500) + 500 },
                { range: '0.6-0.7', count: Math.floor(Math.random() * 200) + 100 },
                { range: '0.5-0.6', count: Math.floor(Math.random() * 100) + 50 }
            ];
            
            // Generate alerts
            const alerts = [
                {
                    severity: 'warning',
                    title: 'High Resolution Time Detected',
                    message: 'Selector product_title resolution time exceeded threshold',
                    time: new Date(now.getTime() - 30 * 60 * 1000)
                },
                {
                    severity: 'info',
                    title: 'New Selector Added',
                    message: 'Selector shipping_info has been added to monitoring',
                    time: new Date(now.getTime() - 60 * 60 * 1000)
                }
            ];
            
            if (Math.random() > 0.7) {
                alerts.push({
                    severity: 'critical',
                    title: 'Error Rate Spike',
                    message: 'Error rate increased to 8.5% for checkout selectors',
                    time: new Date(now.getTime() - 15 * 60 * 1000)
                });
            }
            
            return {
                metrics,
                performanceData,
                errorData,
                usageData,
                confidenceData,
                alerts,
                timeRange
            };
        }
        
        // Generate time series data points
        function generateTimeSeries(startTime, endTime, timeRange) {
            const points = [];
            let interval;
            
            switch(timeRange) {
                case '1h':
                    interval = 5 * 60 * 1000; // 5 minutes
                    break;
                case '6h':
                    interval = 15 * 60 * 1000; // 15 minutes
                    break;
                case '24h':
                    interval = 60 * 60 * 1000; // 1 hour
                    break;
                case '7d':
                    interval = 6 * 60 * 60 * 1000; // 6 hours
                    break;
                case '30d':
                    interval = 24 * 60 * 60 * 1000; // 1 day
                    break;
                default:
                    interval = 60 * 60 * 1000;
            }
            
            for (let time = startTime; time <= endTime; time = new Date(time.getTime() + interval)) {
                points.push(time);
            }
            
            return points;
        }
        
        // Update metrics display
        function updateMetrics(metrics) {
            const metricsGrid = document.getElementById('metricsGrid');
            
            const metricsData = [
                {
                    title: 'Total Operations',
                    value: metrics.totalOperations.toLocaleString(),
                    change: '+12%',
                    positive: true
                },
                {
                    title: 'Avg Resolution Time',
                    value: `${metrics.averageResolutionTime.toFixed(1)}ms`,
                    change: '-5%',
                    positive: true
                },
                {
                    title: 'Success Rate',
                    value: `${(metrics.successRate * 100).toFixed(1)}%`,
                    change: '+2%',
                    positive: true
                },
                {
                    title: 'Error Rate',
                    value: `${(metrics.errorRate * 100).toFixed(2)}%`,
                    change: '+0.5%',
                    positive: false
                },
                {
                    title: 'Avg Confidence',
                    value: metrics.averageConfidence.toFixed(3),
                    change: '+1%',
                    positive: true
                },
                {
                    title: 'Memory Usage',
                    value: `${metrics.memoryUsage.toFixed(1)}MB`,
                    change: '+8%',
                    positive: false
                },
                {
                    title: 'Throughput',
                    value: `${metrics.throughput.toFixed(0)} ops/sec`,
                    change: '+15%',
                    positive: true
                },
                {
                    title: 'Active Selectors',
                    value: metrics.activeSelectors,
                    change: '+3',
                    positive: true
                }
            ];
            
            metricsGrid.innerHTML = metricsData.map(metric => `
                <div class="metric-card">
                    <h3>${metric.title}</h3>
                    <div class="metric-value">${metric.value}</div>
                    <div class="metric-change ${metric.positive ? 'positive' : 'negative'}">
                        ${metric.change} from previous period
                    </div>
                </div>
            `).join('');
        }
        
        // Update all charts
        function updateCharts(data) {
            updatePerformanceChart(data.performanceData);
            updateUsageChart(data.usageData);
            updateConfidenceChart(data.confidenceData);
            updateErrorChart(data.errorData);
        }
        
        // Update performance chart
        function updatePerformanceChart(data) {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            
            if (charts.performance) {
                charts.performance.destroy();
            }
            
            charts.performance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => formatTime(d.time)),
                    datasets: [{
                        label: 'Resolution Time (ms)',
                        data: data.map(d => d.resolutionTime),
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        yAxisID: 'y'
                    }, {
                        label: 'Throughput (ops/sec)',
                        data: data.map(d => d.throughput),
                        borderColor: '#28a745',
                        backgroundColor: 'rgba(40, 167, 69, 0.1)',
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Resolution Time (ms)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Throughput (ops/sec)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }
        
        // Update usage chart
        function updateUsageChart(data) {
            const ctx = document.getElementById('usageChart').getContext('2d');
            
            if (charts.usage) {
                charts.usage.destroy();
            }
            
            charts.usage = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: data.map(d => d.selector),
                    datasets: [{
                        data: data.map(d => d.count),
                        backgroundColor: [
                            '#667eea',
                            '#764ba2',
                            '#f093fb',
                            '#4facfe',
                            '#43e97b'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }
        
        // Update confidence chart
        function updateConfidenceChart(data) {
            const ctx = document.getElementById('confidenceChart').getContext('2d');
            
            if (charts.confidence) {
                charts.confidence.destroy();
            }
            
            charts.confidence = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.range),
                    datasets: [{
                        label: 'Count',
                        data: data.map(d => d.count),
                        backgroundColor: '#667eea'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Operations'
                            }
                        }
                    }
                }
            });
        }
        
        // Update error chart
        function updateErrorChart(data) {
            const ctx = document.getElementById('errorChart').getContext('2d');
            
            if (charts.error) {
                charts.error.destroy();
            }
            
            charts.error = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => formatTime(d.time)),
                    datasets: [{
                        label: 'Error Rate (%)',
                        data: data.map(d => d.errorRate * 100),
                        borderColor: '#dc3545',
                        backgroundColor: 'rgba(220, 53, 69, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Error Rate (%)'
                            }
                        }
                    }
                }
            });
        }
        
        // Update alerts display
        function updateAlerts(alerts) {
            const alertsContainer = document.getElementById('alertsContainer');
            
            if (alerts.length === 0) {
                alertsContainer.innerHTML = '<p>No recent alerts</p>';
                return;
            }
            
            alertsContainer.innerHTML = alerts.map(alert => `
                <div class="alert-item ${alert.severity}">
                    <div class="alert-title">
                        <span class="status-indicator ${alert.severity}"></span>
                        ${alert.title}
                    </div>
                    <div>${alert.message}</div>
                    <div class="alert-time">${formatTime(alert.time)}</div>
                </div>
            `).join('');
        }
        
        // Utility functions
        function formatTime(date) {
            return new Intl.DateTimeFormat('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            }).format(date);
        }
        
        function showLoading(show) {
            document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
        }
        
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }
        
        function hideError() {
            document.getElementById('errorContainer').innerHTML = '';
        }
        
        // Auto-refresh every 30 seconds
        setInterval(refreshDashboard, 30000);
    </script>
</body>
</html>
